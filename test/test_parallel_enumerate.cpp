#include "enumerate_subtrees.hpp"
#include "permutation.hpp"
#include "subtree_test_helpers.hpp"

#include <catch2/catch_test_macros.hpp>

#include <algorithm>
#include <vector>

/**
 * @brief Enumerates all graphs in parallel and checks to ensure the set of
 * generated graphs is equal to the set generated by applying all permutations
 * to each given subtree.
 * @param graph The graph to enumerate
 * @param perm_set The set of permutations for this graph
 * @param expected_subtree_bases The set of all expected subtrees, where
 * permutations are considered equivalent.
 */
void check_parallel_result(const graph_type &graph,
                           const permutation_set &perm_set,
                           const subtree_set &expected_subtree_bases) {
  subtree_set expected;

  for (const auto &base : expected_subtree_bases) {
    for (const auto &perm : perm_set.perms()) {
      expected.emplace(base.apply_permutation(perm));
    }
  }

  subtree_set result;
  std::mutex m;
  enumerate_recursive(graph, [&m, &result](const subtree_type &sub) {
    std::scoped_lock lock{m};
    result.emplace(sub);
  });

  CHECK(expected.size() == result.size());

  std::vector<subtree_type> res_min_exp, exp_min_res;
  ranges::set_difference(result, expected, std::back_inserter(res_min_exp));
  ranges::set_difference(expected, result, std::back_inserter(res_min_exp));

  for (const auto &sub : res_min_exp) {
    UNSCOPED_INFO(sub);
  }
  CHECK(res_min_exp.empty());

  for (const auto &sub : exp_min_res) {
    UNSCOPED_INFO(sub);
  }
  CHECK(exp_min_res.empty());
}

TEST_CASE("Size = {2,2}, parallel") {
  const graph_type graph{2, 2};
  const std::vector<std::size_t> dims{2, 2};
  const permutation_set perm_set{dims};

  using u8 = std::uint8_t;

  const subtree_set expected_subtree_bases{
      {graph, std::vector<u8>{}},
      {graph, std::vector<u8>{0}},
      {graph, std::vector<u8>{0, 1}},
      {graph, std::vector<u8>{0, 1, 2}},
  };

  check_parallel_result(graph, perm_set, expected_subtree_bases);
}
